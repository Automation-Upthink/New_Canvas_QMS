package com.upthink.qms.controller;import com.upthink.qms.dto.request.*;import com.upthink.qms.dto.response.BaseResponse;import com.upthink.qms.dto.response.CourseResponse;import com.upthink.qms.dto.response.FetchDataForClientResponse;import com.upthink.qms.model.Client;import com.upthink.qms.model.Course;import com.upthink.qms.service.AssignmentService;import com.upthink.qms.service.ClientService;import com.upthink.qms.service.CourseService;import org.springframework.http.ResponseEntity;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.*;import java.util.HashSet;import java.util.List;import java.util.Optional;import java.util.Set;import java.util.stream.Collectors;@RestController@RequestMapping("/api/clients")public class ClientController {    private final ClientService clientService;    private final AssignmentService assignmentService;    private final  CourseService courseService;    public ClientController(ClientService clientService, CourseService courseService, AssignmentService assignmentService) {        this.clientService = clientService;        this.assignmentService = assignmentService;        this.courseService = courseService;    }    @PostMapping("/listClients")    @PreAuthorize("hasAnyRole('QM_ADMIN')")    public ResponseEntity<List<Client>> getAllClients(@RequestBody AuthenticatedRequest request) {        List<Client> clients = clientService.getAllClients();        return ResponseEntity.ok(clients);    }    @GetMapping("/{id}")    @PreAuthorize("hasAnyRole('QM_ADMIN', 'SME', 'USER')")    public ResponseEntity<Client> getClientById(@PathVariable int id, @RequestBody GetClientByIdRequest request) {        Optional<Client> client = clientService.getClientById(id);        return client.map(ResponseEntity::ok).orElseGet(() -> ResponseEntity.notFound().build());    }    @PostMapping("/addClient")    @PreAuthorize("hasRole('QM_ADMIN')")    public ResponseEntity<String> addClient(@RequestBody CreateClientRequest request) {        int clientAddBoolean  = clientService.addNewClient(request.getClientName());        System.out.println("Client bool " + clientAddBoolean);        if (clientAddBoolean == 0)            return ResponseEntity.ok("Client created successfully");        else            return ResponseEntity.notFound().build();    }    @PutMapping("/{id}")    @PreAuthorize("hasRole('QM_ADMIN')")    public ResponseEntity<CourseResponse> updateClient(@RequestBody UpdateClientCoursesRequest request) {        Optional<Client> clientOpt = clientService.getClientById(request.getClientId());        if (clientOpt.isEmpty()) {            return ResponseEntity.notFound().build();        }        Client client = clientOpt.get();        List<Course> currentCourses = courseService.getActiveCoursesForClient(client.getId());        Set<String> currentCourseIds = currentCourses.stream()                .map(Course::getCourseId)                .collect(Collectors.toSet());        // Convert the requested list to a set for easier comparison        Set<String> requestedCourseIds = new HashSet<>(request.getCourseIds());        for (Course course : currentCourses) {            if (!requestedCourseIds.contains(course.getCourseId())) {                courseService.softDeleteCourseById(course.getId());            }        }        System.out.println("Done right");        for (String courseId : requestedCourseIds) {            if (!currentCourseIds.contains(courseId)) {                Course newCourse = new Course(courseId, client.getId()); // Using default (protected) constructor                courseService.saveCourseToDatabase(courseId, client.getId());            }        }        // 5. Return the updated courses list using your existing service function        CourseResponse response = courseService.getCoursesForAClient(client.getId());        return ResponseEntity.ok(response);    }    /*    * Soft delete a client from the database.    * */    @DeleteMapping("/{id}")    @PreAuthorize("hasRole('QM_ADMIN')")    public ResponseEntity<BaseResponse>  deleteClient(@RequestBody DeleteClientRequest request) {        Optional<Client> clientOpt = clientService.getClientById(request.getClientRowId());        if (clientOpt.isPresent()) {            Client client = clientOpt.get();            clientService.deleteClientById(client.getId());            return ResponseEntity.ok(new BaseResponse(true, "Deleted client"));        } else {            return ResponseEntity.badRequest().body(new BaseResponse(false, "Error deleting client"));        }    }//    @PutMapping("/{id}")//    @PreAuthorize("hasRole('QM_ADMIN')")//    public ResponseEntity<String> updateClient(@PathVariable int id, @RequestBody UpdateClientRequest request) {//        Optional<Client> existingClient = clientService.getClientById(id);//        if (existingClient.isPresent()) {//            Client client = request.getData();//            client.setId(id);//            clientService.saveClient(client);//            return ResponseEntity.ok("Client updated successfully");//        } else {//            return ResponseEntity.notFound().build();//        }//    }//    @DeleteMapping("/{id}")//    @PreAuthorize("hasRole('QM_ADMIN')")//    public ResponseEntity<String> deleteClient(@PathVariable int id, @RequestBody DeleteClientRequest request) {//        Optional<Client> existingClient = clientService.getClientById(id);//        if (existingClient.isPresent()) {//            Client client = existingClient.get();//            client.setDeletedAt(new Timestamp(System.currentTimeMillis())); // Soft delete by updating deletedAt//            clientService.saveClient(client);//            return ResponseEntity.ok("Client soft deleted successfully");//        } else {//            return ResponseEntity.notFound().build();//        }//    }    @PostMapping("/fetchDataForClient")    public ResponseEntity fetchDataForClient(@RequestBody FetchDataForClientRequest request) {        System.out.println("Fetch data for client request " + request);        Optional<Client> clientOpt = clientService.getClientById(request.getClientId());        if (clientOpt.isPresent()) {            Client client = (Client) clientOpt.get();            FetchDataForClientResponse assignments = assignmentService.fetchDataForClientService(client.getId());            return ResponseEntity.ok(assignments);        } else {            return ResponseEntity.notFound().build();        }    }}